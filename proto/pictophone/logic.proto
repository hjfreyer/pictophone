syntax = "proto3";

package pictophone.logic;

import "pictophone/v1_0.proto";
import "pictophone/v1_1.proto";

enum ApiVersion {
    V1_0 = 0;
    V1_1 = 1;
}

message EvolveRequest {
    bytes state = 1;
    VersionedAction action = 2;
}

message VersionedAction {
    oneof version {
        pictophone.v1_0.Action v1p0 = 1;
        pictophone.v1_1.Action v1p1 = 2;
    }   
}

message EvolveResponse {
    bytes state = 1;
    VersionedResponse response = 2;
}

message VersionedResponse {
    oneof version {
        pictophone.v1_0.Response v1p0 = 1;
        pictophone.v1_1.Response v1p1 = 2;
    }   
}

message QueryRequest {
    bytes state = 1;
    VersionedQueryRequest query = 2;
}

message VersionedQueryRequest {
    oneof version {
        pictophone.v1_0.QueryRequest v1p0 = 1;
        pictophone.v1_1.QueryRequest v1p1 = 2;
    }   
}

message VersionedQueryResponse {
    oneof version {
        pictophone.v1_0.QueryResponse v1p0 = 1;
        pictophone.v1_1.QueryResponse v1p1 = 2;
    }   
}

message Request {
    oneof method {
        EvolveRequest evolve_request = 1;
        QueryRequest query_request = 2;
    }
}

message Response {
    oneof method {
        EvolveResponse evolve_response = 1;
        VersionedQueryResponse versioned_query_response = 2;
    }
}
// mesage EvolveResponse {
//     bytes state = 0;
//     oneof version {
//         Response1_0 v1_0 = 1;
//     }
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub struct EvolveResponse {
//     pub state: Option<Vec<u8>>,
//     pub response: VersionedResponse,
// }


// message Action1_0 {
//     oneof kind {
//         pictophone.v1_0.CreateGameRequest create_game = 0;
//         pictophone.v1_0.DeleteGameRequest delete_game = 1;
//     }
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum Response {
//     Ok,
//     GameNotFound { game_id: GameId },
//     GameAlreadyExists { game_id: GameId },
//     ShortCodeInUse { short_code: ShortCodeId },
// }



// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum VersionedAction {
//     V1_0(v1_0::Action),
//     V1_1(v1_0::Action),
// }

// impl VersionedAction {
//     pub fn version(&self) -> ApiVersion {
//         match self {
//             VersionedAction::V1_0(_) => ApiVersion::V1_0,
//             VersionedAction::V1_1(_) => ApiVersion::V1_1,
//         }
//     }
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum VersionedResponse {
//     V1_0(v1_0::Response),
//     V1_1(v1_0::Response),
// }


// impl VersionedResponse {
//     pub fn version(&self) -> ApiVersion {
//         match self {
//             VersionedResponse::V1_0(_) => ApiVersion::V1_0,
//             VersionedResponse::V1_1(_) => ApiVersion::V1_1,
//         }
//     }
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum VersionedWatchRequest {
//     V1_1(v1_1::WatchRequest),
// }


// impl VersionedWatchRequest {
//     pub fn version(&self) -> ApiVersion {
//         match self {
//             VersionedWatchRequest::V1_1(_) => ApiVersion::V1_1,
//         }
//     }
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum VersionedWatchResponse {
//     V1_1(v1_1::WatchResponse),
// }


// impl VersionedWatchResponse {
//     pub fn version(&self) -> ApiVersion {
//         match self {
//             VersionedWatchResponse::V1_1(_) => ApiVersion::V1_1,
//         }
//     }
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum LogicRequest {
//     Evolve(EvolveRequest),
//     Watch(WatchRequest),
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub enum LogicResponse {
//     Evolve(EvolveResponse),
//     Watch(WatchResponse),
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub struct EvolveRequest {
//     pub state: Option<Vec<u8>>,
//     pub action: VersionedAction,
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub struct EvolveResponse {
//     pub state: Option<Vec<u8>>,
//     pub response: VersionedResponse,
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub struct WatchRequest {
//     pub state: Option<Vec<u8>>,
//     pub request: VersionedWatchRequest,
// }

// #[derive(Debug, Clone, Serialize, Deserialize)]
// pub struct WatchResponse {
//     pub state: Option<Vec<u8>>,
//     pub response: VersionedWatchResponse,
// }



// // mod base64 {
// //     use base64;
// //     use serde::{Serializer, de, Deserialize, Deserializer};

// //     pub fn serialize<S>(bytes: &[u8], serializer: S) -> Result<S::Ok, S::Error>
// //         where S: Serializer
// //     {
// //         serializer.serialize_ ;
// //         serialize_str(&base64::encode(bytes))

// //         // Could also use a wrapper type with a Display implementation to avoid
// //         // allocating the String.
// //         //
// //         // serializer.collect_str(&Base64(bytes))
// //     }

// //     pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>
// //         where D: Deserializer<'de>
// //     {
// //         let s = <&str>::deserialize(deserializer)?;
// //         base64::decode(s).map_err(de::Error::custom)
// //     }
// // }
